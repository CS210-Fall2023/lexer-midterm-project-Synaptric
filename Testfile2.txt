module (keyword)
trie (identifier)
is (keyword)
Num_Branches (identifier)
:
constant (keyword)
positive (keyword)
:=
27 (numeric literal)
;
type (keyword)
node_type (identifier)
is (keyword)
(
Nt_Branch (identifier)
,
Nt_Data (identifier)
);
type (keyword)
trie_type (identifier)
is (keyword)
struct (keyword)
root (identifier)
:
ptr_type (identifier)
:=
null (keyword)
;
size (identifier)
:
natural (keyword)
:=
0 (numeric literal)
;
end (keyword)
struct (keyword)
;
type (keyword)
datanode_type (identifier)
is (keyword)
struct (keyword)
kind (identifier)
:
node_type (identifier)
:=
Nt_Data (identifier)
;
key (identifier)
:
trie_key_type (identifier)
:=
"dfltkeyval" (string)
;
cargo (identifier)
:
ptr_type (identifier)
:=
null (keyword)
;
end (keyword)
struct (keyword)
;
type (keyword)
branchnode_type (identifier)
is (keyword)
struct (keyword)
kind (identifier)
:
node_type (identifier)
:=
Nt_Branch (identifier)
;
branches (identifier)
:
ptr_type (identifier)
(1 (numeric literal)
..NumBranches (identifier)
);
end (keyword)
struct (keyword)
;
procedure (keyword)
make_uppercase (identifier)
(key (identifier)
:
in (keyword)
out (keyword)
trie_key_type (identifier)
)
is (keyword)
i (identifier)
:
positive (keyword)
:=
1 (numeric literal)
;
begin (keyword)
while (keyword)
(i (identifier)
<=
key (identifier)
.length (identifier)
())
loop (keyword)
if (keyword)
((key (identifier)
[i (identifier)
]
>=
'a' (character literal))
and (keyword)
(key (identifier)
[i (identifier)
]
<=
'z' (character literal)))
then (keyword)
key (identifier)
[i (identifier)
]
:=
'A' (character literal)
+
(key (identifier)
[i (identifier)
]
-
'a' (character literal));
end (keyword)
if (keyword)
;
i (identifier)
:=
i (identifier)
+
1 (numeric literal)
;
end (keyword)
loop (keyword)
;
end (keyword)
make_uppercase (identifier)
;
function (keyword)
lkup (identifier)
(p (identifier)
:
in (keyword)
out (keyword)
ptr_type (identifier)
;
k (identifier)
:
trie_key_type (identifier)
)
return (keyword)
datanode_type (identifier)
is (keyword)
i (identifier)
:
integer (keyword)
;
n (identifier)
:
integer (keyword)
;
c (identifier)
:
character (keyword)
;
dp (identifier)
:
datanode_type (identifier)
;
bp (identifier)
:
branchnode_type (identifier)
;
begin (keyword)
i (identifier)
:=
0 (numeric literal)
;
dp (identifier)
:=
p (identifier)
;
bp (identifier)
:=
p (identifier)
;
<</**/ (comment)L_Discriminant_Test/**/ (comment)>>
while (keyword)
((p (identifier)
!=
null (keyword)
)
and (keyword)
(bp (identifier)
.kind (identifier)
=
Nt_Branch (identifier)
))
loop (keyword)
c (identifier)
:=
k (identifier)
[i (identifier)
];
i (identifier)
:=
i (identifier)
+
1 (numeric literal)
;
if (keyword)
(c (identifier)
>
0 (numeric literal)
)
then (keyword)
n (identifier)
:=
c (identifier)
-
'A' (character literal)
+
1 (numeric literal)
;
else (keyword)
n (identifier)
:=
0 (numeric literal)
;
end (keyword)
if (keyword)
;
p (identifier)
:=
bp (identifier)
.branches (identifier)
[k (identifier)
];
<<L_Discriminant_Assign (identifier)
>>
<<L_Discriminant_Rhs (identifier)
>>
bp (identifier)
:=
p (identifier)
;
end (keyword)
loop (keyword)
;
dp (identifier)
:=
p (identifier)
;
if (keyword)
(dp (identifier)
=
null (keyword)
)
then (keyword)
return (keyword)
null (keyword)
;
elsif (keyword)
(key (identifier)
=
dp (identifier)
.key (identifier)
)
then (keyword)
return (keyword)
dp (identifier)
;
else (keyword)
return (keyword)
null (keyword)
;
end (keyword)
if (keyword)
;
end (keyword)
lkup (identifier)
;
procedure (keyword)
insert_key_data_pair (identifier)
(
p (identifier)
:
in (keyword)
out (keyword)
ptr_type (identifier)
;
key (identifier)
:
in (keyword)
trie_key_type (identifier)
;
cargo (identifier)
:
ptr_type (identifier)
;
i (identifier)
:
natural (keyword)
;
was_added (identifier)
:
boolean (identifier)
)
is (keyword)
k (identifier)
,
k1 (identifier)
 (numeric (identifier)
 literal (identifier)
)
:
integer (keyword)
;
ch (identifier)
,
ch1 (identifier)
 (numeric (identifier)
 literal (identifier)
)
:
character (keyword)
;
dp (identifier)
:
datanode_type (identifier)
;
bp (identifier)
:
branchnode_type (identifier)
;
bp1 (identifier)
 (numeric (identifier)
 literal (identifier)
)
:
branchnode_type (identifier)
;
begin (keyword)
while (keyword)
(1 (numeric literal)

=
1 (numeric literal)
)
loop (keyword)
if (keyword)
(p (identifier)
=
null (keyword)
)
then (keyword)
p (identifier)
:=
alloc (identifier)
(datanode_type (identifier)
);
<<L_Discriminant_Alloc (identifier)
>>
p (identifier)
.key (identifier)
:=
key (identifier)
;
p (identifier)
.cargo (identifier)
:=
cargo (identifier)
;
break (identifier)
;
end (keyword)
if (keyword)
;
bp (identifier)
:=
p (identifier)
;
dp (identifier)
:=
p (identifier)
;
ch (identifier)
:=
key (identifier)
[i (identifier)
];
if (keyword)
(ch (identifier)
>
0 (numeric literal)
)
then (keyword)
k (identifier)
:=
ch (identifier)
-
'A' (character literal)
+
1 (numeric literal)
;
else (keyword)
k (identifier)
:=
0 (numeric literal)
;
end (keyword)
if (keyword)
;
if (keyword)
(bp (identifier)
.kind (identifier)
=
Nt_Branch (identifier)
)
then (keyword)
/* it is a branch node */ (comment)
<<L_Discriminant_Assign (identifier)
>>
p (identifier)
:=
bp (identifier)
.branches (identifier)
[k (identifier)
];
else (keyword)
/* it is a data node */ (comment)
if (keyword)
(key (identifier)
=
dp (identifier)
.key (identifier)
)
then (keyword)
/*
                     * There is already cargo associated with this key in the
                     * table. There can only be one datum associated with any
                     * given key for the lifetime of this table.
                     */ (comment)
was_added (identifier)
:=
false (identifier)
;
break (identifier)
;
else (keyword)
was_added (identifier)
:=
true (identifier)
;
end (keyword)
if (keyword)
;
bp1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

:=
alloc (identifier)
(branchnode_type (identifier)
);
<<L_Discriminant_Assign (identifier)
>>
p (identifier)
:=
bp1 (identifier)
 (numeric (identifier)
 literal (identifier)
)
;
ch1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

:=
dp (identifier)
.key (identifier)
[i (identifier)
];
/* char in existing node */ (comment)
if (keyword)
(ch1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

>
0 (numeric literal)
)
then (keyword)
k1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

:=
ch1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

-
'A' (character literal)
+
1 (numeric literal)
;
else (keyword)
k1 (identifier)
 (numeric (identifier)
 literal (identifier)
)

:=
0 (numeric literal)
;
end (keyword)
if (keyword)
;
bp1b (identifier)
 (numeric (identifier)
 literal (identifier)
)
branches (identifier)
[k1 (identifier)
 (numeric (identifier)
 literal (identifier)
)
]
:=
bp (identifier)
;
<<L_Discriminant_Transitive_Rhs (identifier)
>>
<<L_Discriminant_Assign (identifier)
>>
p (identifier)
:=
bp1b (identifier)
 (numeric (identifier)
 literal (identifier)
)
branches (identifier)
[k (identifier)
];
end (keyword)
if (keyword)
;
i (identifier)
:=
i (identifier)
+
1 (numeric literal)
;
end (keyword)
loop (keyword)
;
end (keyword)
insert_key_data_pair (identifier)
;
function (keyword)
find (identifier)
(t (identifier)
:
in (keyword)
trie_type (identifier)
;
key (identifier)
:
in (keyword)
trie_key_type (identifier)
)
return (keyword)
ptr_type (identifier)
is (keyword)
np (identifier)
:
datanode_type (identifier)
;
begin (keyword)
make_uppercase (identifier)
(key (identifier)
);
np (identifier)
:=
lkup (identifier)
(t (identifier)
.root (identifier)
,
key (identifier)
);
if (keyword)
(np (identifier)
=
null (keyword)
)
then (keyword)
return (keyword)
null (keyword)
;
else (keyword)
return (keyword)
np (identifier)
.cargo (identifier)
;
end (keyword)
if (keyword)
;
end (keyword)
find (identifier)
;
mutator (keyword)
insert (identifier)
(t (identifier)
:
in (keyword)
out (keyword)
trie_type (identifier)
;
k (identifier)
:
in (keyword)
trie_key_type (identifier)
;
x (identifier)
:
in (keyword)
ptr_type (identifier)
)
is (keyword)
dn (identifier)
:
datanode_type (identifier)
;
was_added (identifier)
:
boolean (identifier)
:=
false (identifier)
;
begin (keyword)
make_uppercase (identifier)
(k (identifier)
);
insert_key_data_pair (identifier)
(t (identifier)
.root (identifier)
,
k (identifier)
,
cargo (identifier)
,
0 (numeric literal)
,
was_added (identifier)
);
if (keyword)
(was_added (identifier)
)
then (keyword)
t (identifier)
.size (identifier)
:=
t (identifier)
.size (identifier)
+
1 (numeric literal)
;
end (keyword)
if (keyword)
;
end (keyword)
insert (identifier)
;
accessor (keyword)
size (identifier)
(t (identifier)
:
in (keyword)
trie_type (identifier)
)
return (keyword)
natural (keyword)
is (keyword)
begin (keyword)
return (keyword)
t (identifier)
.size (identifier)
;
end (keyword)
size (identifier)
;
end (keyword)
trie (identifier)
;
